#include <stdio.h>
#include <string.h>
#include <malloc.h>

// Estrutura arvore
typedef struct No{
    int numero;
    struct No *esquerda;
    struct No *direita;
}No;


typedef struct No *arvore; //Ponteiro da raiz

void criarArvore(arvore *pRaiz);

void inserir (arvore *pRaiz, int x);
void remover(No **pRaiz, int numero);
int ContarFolhas(No *pRaiz);
int contarNos(No *pRaiz);
void exibirEmOrdem (arvore pRaiz);
void exibirPreOrdem (arvore pRaiz);
void exibirPosOrdem (arvore pRaiz);


// Inicializar arvore

void criarArvore(No **pRaiz){
    *pRaiz = NULL;
}

//Insercao

void inserir(No **pRaiz, int numero){
    if(*pRaiz == NULL){
        *pRaiz = (No *) malloc(sizeof(No));
        (*pRaiz)->esquerda = NULL;
        (*pRaiz)->direita = NULL;
        (*pRaiz)->numero = numero;
    }else{
        if(numero < (*pRaiz)->numero)
            inserir(&(*pRaiz)->esquerda, numero);
        if(numero > (*pRaiz)->numero)
            inserir(&(*pRaiz)->direita, numero);
    }
}

//Remocao

No *MaiorDireita(No **no){
    if((*no)->direita != NULL)
       return MaiorDireita(&(*no)->direita);
    else{
       No *aux = *no;
       if((*no)->esquerda != NULL) // se nao houver essa verificacao, esse noh vai perder todos os seus filhos da esquerda!
          *no = (*no)->esquerda;
       else
          *no = NULL;
       return aux;
       }
}

No *MenorEsquerda(No **no){
    if((*no)->esquerda != NULL)
       return MenorEsquerda(&(*no)->esquerda);
    else{
       No *aux = *no;
       if((*no)->direita != NULL) // se nao houver essa verificacao, esse noh vai perder todos os seus filhos da direita!
          *no = (*no)->direita;
       else
          *no = NULL;
       return aux;
       }
}
 // Remover
void remover(No **pRaiz, int numero){
    if(*pRaiz == NULL){   // esta verificacao serve para caso o numero nao exista na arvore.
       printf("Numero nao existe na arvore!");
       getchar();
       return;
    }
    if(numero < (*pRaiz)->numero)
       remover(&(*pRaiz)->esquerda, numero);
    else
       if(numero > (*pRaiz)->numero)
          remover(&(*pRaiz)->direita, numero);
       else{    // se nao eh menor nem maior, logo, eh o numero que estou procurando! :)
          No *pAux = *pRaiz;     // quem programar no Embarcadero vai ter que declarar o pAux no inicio do void! :[
          if (((*pRaiz)->esquerda == NULL) && ((*pRaiz)->direita == NULL)){         // se nao houver filhos...
                free(pAux);
                (*pRaiz) = NULL;
               }
          else{     // so tem o filho da direita
             if ((*pRaiz)->esquerda == NULL){
                (*pRaiz) = (*pRaiz)->direita;
                pAux->direita = NULL;
                free(pAux); pAux = NULL;
                }
             else{            //so tem filho da esquerda
                if ((*pRaiz)->direita == NULL){
                    (*pRaiz) = (*pRaiz)->esquerda;
                    pAux->esquerda = NULL;
                    free(pAux); pAux = NULL;
                    }
                else{       //Escolhi fazer o maior filho direito da subarvore esquerda.
                   pAux = MaiorDireita(&(*pRaiz)->esquerda); //se vc quiser usar o Menor da esquerda, so o que mudaria seria isso:
                   pAux->esquerda = (*pRaiz)->esquerda;          //        pAux = MenorEsquerda(&(*pRaiz)->direita);
                   pAux->direita = (*pRaiz)->direita;
                   (*pRaiz)->esquerda = (*pRaiz)->direita = NULL;
                   free((*pRaiz));  *pRaiz = pAux;  pAux = NULL;
                   }
                }
             }
          }
}


//Em ordem

void exibirEmOrdem(No *pRaiz){
    if(pRaiz != NULL){
        exibirEmOrdem(pRaiz->esquerda);
        printf("\n%i", pRaiz->numero);
        exibirEmOrdem(pRaiz->direita);
    }
}

//Pre-ordem

void exibirPreOrdem(No *pRaiz){
    if(pRaiz != NULL){
        printf("\n%i", pRaiz->numero);
        exibirPreOrdem(pRaiz->esquerda);
        exibirPreOrdem(pRaiz->direita);
    }
}

//Pos-ordem

void exibirPosOrdem(No *pRaiz){
    if(pRaiz != NULL){
        exibirPosOrdem(pRaiz->esquerda);
        exibirPosOrdem(pRaiz->direita);
        printf("\n%i", pRaiz->numero);
    }
}

//Contar
int contarNos(No *pRaiz){
   if(pRaiz == NULL)
        return 0;
   else
        return 1 + contarNos(pRaiz->esquerda) + contarNos(pRaiz->direita);
}

//Contar folhas
int contarFolhas(No *pRaiz){
   if(pRaiz == NULL)
        return 0;
   if(pRaiz->esquerda == NULL && pRaiz->direita == NULL)
        return 1;
   return contarFolhas(pRaiz->esquerda) + contarFolhas(pRaiz->direita);
}

// maior

int maior(int a, int b){
    if(a > b)
        return a;
    else
        return b;
}

 //Altura da arvore

int altura(No *pRaiz){
   if((pRaiz == NULL) || (pRaiz->esquerda == NULL && pRaiz->direita == NULL))
       return 0;
   else
       return 1 + maior(altura(pRaiz->esquerda), altura(pRaiz->direita));
}


//main

int main(void) {
    int n = 0;
    int num = 0;
    int x;

    arvore A;

    criarArvore(&A);

    // insercao dos elementos na arvore binaria
     printf("Digite a quantidade de nohs da arvore\n");
     scanf("%d", &x);

    for (n = 0 ; n < x ; n++)
    {
     printf("Digite um elemento\n");
     scanf("%d", &num);
     inserir(&A,num);


}

    // impressao dos elementos da arvore binaria em ordem

    printf("\nOs elementos da arvore em ordem:");
    exibirEmOrdem(A);
    getchar();
    printf("\nOs elementos da arvore pre-ordem:");
    exibirPreOrdem(A);
    getchar();
    printf("\nOs elementos da arvore pos-ordem:");
    exibirPosOrdem(A);
    printf("\nQuantidade de nohs= %d\n",  contarNos(A));
    printf("\nQuantidade de folhas= %d\n",  contarFolhas(A));
     printf("\nAltura da arvore= %d\n",  altura(A));
    getchar();
    printf("\nDigite um elemento para ser eliminado:\n");
    scanf("%d", &num);
    remover(&A,num);

    printf("\nOs elementos restantes da arvore em ordem:");
    exibirEmOrdem(A);

    printf("\nQuantidade de nohs= %d\n",  contarNos(A));
    printf("\nQuantidade de folhas= %d\n",  contarFolhas(A));
    printf("\nAltura da arvore= %d\n",  altura(A));
    getchar();
    getchar();

    return 0;

}
